from bitarray import bitarray
from mnemonic import Mnemonic


def word_to_bitstring(mnemo: Mnemonic, word: str) -> str:
    index = mnemo.wordlist.index(word)
    if index < 0:
        raise LookupError('Unable to find "%s" in word list.' % word)

    eleven_bit_string = format(index, "011b")

    return eleven_bit_string


class ChecksumGenerator:
    def __init__(self, ent_phrase: str, coin_flips: str, mnemo: Mnemonic):
        """
        :param ent_phrase: the initial entropy phrase (ENT), space separated. For
        example, when generating a 24 word phrase you need to supply the first 23 words.

        :param coin_flips: a bit string generated by coin flips to represent the
        first N bits of the last word. The last (11 - N) bits is the checksum value.
        All these bits together determine the last word. For example, when generating a
        24 word phrase, the checksum is 8 bits, so the bit string needs to contain 3
        bits.
        """

        self.mnemo = mnemo

        number_of_words = len(ent_phrase.split(" "))

        if number_of_words not in [11, 14, 17, 20, 23]:
            raise ValueError("The entropy phrase isn't the right length")

        desired_bits_entropy_plus_checksum = (number_of_words + 1) * 11

        number_of_checksum_bits = desired_bits_entropy_plus_checksum // 32

        assert (
            number_of_checksum_bits + number_of_checksum_bits * 32
            == desired_bits_entropy_plus_checksum
        )

        if len(coin_flips) != 11 - number_of_checksum_bits:
            raise ValueError("The coin flip bitstring isn't the right length")

        self.ent_phrase = ent_phrase
        self.coin_flips = coin_flips
        self.ent = self.ent_phrase_and_coin_flips_to_bytes()

    def ent_phrase_and_coin_flips_to_bytes(self) -> bytes:
        bits = ""

        for word in self.ent_phrase.split(" "):
            bits += word_to_bitstring(self.mnemo, word)

        bits += self.coin_flips

        # TODO: We probably don't need to add 7 here since the number of bits should
        #  always be a multiple of 8
        return int(bits, 2).to_bytes((len(bits) + 7) // 8, "big")
