from bitarray import bitarray
from mnemonic import Mnemonic


def word_to_bitstring(mnemo: Mnemonic, word: str) -> str:
    index = mnemo.wordlist.index(word)
    if index < 0:
        raise LookupError('Unable to find "%s" in word list.' % word)

    # The format string "011b" means "print number in binary with eleven digits, left
    # padded with zeros".
    eleven_bit_string = format(index, "011b")

    return eleven_bit_string


class ChecksumGenerator:
    def __init__(self, ent_phrase: str, coin_flips: str, mnemo: Mnemonic):
        """
        :param ent_phrase: the initial entropy phrase (ENT), space separated. For
        example, when generating a 24 word phrase you need to supply the first 23 words.

        :param coin_flips: a bit string generated by coin flips to represent the
        first N bits of the last word. The last (11 - N) bits is the checksum value.
        All these bits together determine the last word. For example, when generating a
        24 word phrase, the checksum is 8 bits, so the bit string needs to contain 3
        bits.
        """

        self.mnemo = mnemo

        # The phrase should be space separated
        number_of_words = len(ent_phrase.split(" "))

        # See the BIP-39 specification for the allowed lengths (12, 15, 18, 21, 24).
        # Since we are generating the words using dice, the last word is not included
        # in our initial input.
        if number_of_words not in [11, 14, 17, 20, 23]:
            raise ValueError("The entropy phrase isn't the right length")

        # Each word in the phrase is represented by eleven bits. Here we find the total
        # number of bits in the final phrase.
        desired_bits_entropy_plus_checksum = (number_of_words + 1) * 11

        # The initial entropy of a standard BIP-39 phrase is a multiple of 32 bits. The
        # number of checksum bits is however many extra bits on top of that which will
        # bring the total to be divisible by eleven. Thus, we can use integer division
        # to ignore the checksum bits to work backwards and find how many checksum bits
        # there should be.
        number_of_checksum_bits = desired_bits_entropy_plus_checksum // 32

        # Logically, the following relations should also hold.
        assert number_of_checksum_bits == desired_bits_entropy_plus_checksum % 32
        assert (
            number_of_checksum_bits + number_of_checksum_bits * 32
            == desired_bits_entropy_plus_checksum
        )

        number_of_coin_flip_bits = 11 - number_of_checksum_bits
        if len(coin_flips) != number_of_coin_flip_bits:
            raise ValueError(
                f"The coin flip bitstring isn't the right length"
                f" (expected {number_of_coin_flip_bits})"
            )

        self.ent_phrase = ent_phrase
        self.coin_flips = coin_flips
        self.ent = self.ent_phrase_and_coin_flips_to_bytes()

    def ent_phrase_and_coin_flips_to_bytes(self) -> bytes:
        bits = ""

        for word in self.ent_phrase.split(" "):
            bits += word_to_bitstring(self.mnemo, word)

        bits += self.coin_flips

        # TODO: We probably don't need to add 7 here since the number of bits should
        #  always be a multiple of 8
        return int(bits, 2).to_bytes((len(bits) + 7) // 8, "big")
